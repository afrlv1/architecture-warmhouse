# Project_template

# Задание 1. Анализ и планирование

<aside>

Проектная работа: экосистема «Тёплый дом»
Введение

Цель работы — спроектировать и частично реализовать целевую микросервисную экосистему умного дома для компании «Тёплый дом», исходя из исходного монолита (управление отоплением) и новых бизнес-требований (SaaS, самообслуживание, расширенный набор устройств, сценарии и телеметрия).

Работа включает:

анализ текущего монолита и выделение доменов;

проектирование микросервисной архитектуры (C4: Context, Containers, Components, Code);

разработку ER-диаграммы;

документирование API (REST + AsyncAPI);

реализацию и упаковку сервиса temperature-api в Docker + настройку Postgres для smart_home.

</aside>

## 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователь через веб-интерфейс может удалённо включать/выключать отопление в доме.

**Мониторинг температуры:**

- Пользователь может просмотреть текущую температуру через веб-клиент.
- Система по запросу сервера получает текущую температуру от датчиков.

**Установка и подключение оборудования:**

- Пользователь не может самостоятельно зарегистрировать и подключить свой датчик/модуль.
- Подключение системы выполняется только специалистом компании.

## 2. Анализ архитектуры монолитного приложения

Текущее решение представляет собой монолитное приложение, обладающее следующими характеристиками:

### **Технологический стек**
- **Язык программирования:** Go  
- **СУБД:** PostgreSQL  
- **Архитектурный стиль:** монолит  
- **Развёртывание:** единый артефакт, обновляется целиком, требует полной остановки приложения

### **Функциональность монолита**
- Управление отоплением (включение/выключение)
- Получение температуры от датчиков по запросу
- Отображение текущих значений через веб-клиент
- Подключение устройств осуществляется только специалистом компании

### **Особенности взаимодействия**
- Все вызовы — **синхронные**
- Сервер самостоятельно инициирует опрос датчиков
- Взаимодействие идёт напрямую от сервера к устройствам

### **Ограничения архитектуры**
- **Ограниченная масштабируемость:** невозможно масштабировать отдельные части системы (например, только работу с отоплением)
- **Жёсткая связанность компонентов:** логика, API, работа с БД и интеграции находятся внутри одного приложения
- **Сложность внедрения новых модулей:** добавление освещения, ворот, камер, сценариев требует изменения монолита
- **Зависимость от штатных специалистов:** пользователь не может подключить своё устройство самостоятельно
- **Низкая гибкость:** нет реактивного взаимодействия, нет событийной модели, нет асинхронной обработки телеметрии

### **Итог**
Монолит подходит для простого управления отоплением, но не масштабируется под задачи экосистемы и SaaS-модели, что делает переход к микросервисной архитектуре необходимым.

## 3. Определение доменов и границы контекстов

На основании требований To-Be выделены домены и bounded contexts.

## Основные домены (To-Be)

### 1. Device Management (Управление устройствами)

- регистрация и активация устройств;
- привязка к домам и комнатам;
- хранение метаданных типов устройств (`DeviceType`, `Module`).

### 2. Heating (Отопление)

- управление режимами отопления;
- установка целевой температуры;
- получение состояния модуля отопления.

### 3. Lighting (Освещение)

- включение/выключение света;
- сценарии освещения.

### 4. Gates (Ворота)

- открытие/закрытие ворот;
- контроль состояния.

### 5. Surveillance (Наблюдение)

- управление доступом к видеопотоку;
- интеграция с внешними видеосистемами (логика доступа и управления, не хранение потоков внутри).

### 6. Telemetry (Телеметрия)

- приём телеметрии от устройств (температура, состояние, события);
- хранение и предоставление данных другим сервисам.

### 7. Scenario / Automation (Сценарии и автоматизация)

- хранение сценариев;
- условия и действия;
- инициирование команд в другие сервисы (`Heating`, `Lighting`, `Gates`).

### 8. User / Access (Пользователи и доступ)

- управление пользователями;
- аутентификация/авторизация.

## **4. Проблемы монолитного решения**

- Масштабирование только целиком. Нельзя независимо масштабировать управление отоплением, работу с устройствами, телеметрию и т.п.
- Синхронное взаимодействие с устройствами. Сервер должен опрашивать устройства, что при росте числа домов и датчиков приводит к росту задержек и нагрузки.
- Отсутствие самообслуживания. Пользователь не может сам зарегистрировать/подключить устройство, что тормозит развитие SaaS-модели
- Сложности с расширением. Добавление новых функций (освещение, ворота, камеры, сценарии) в один монолит ухудшает сопровождаемость и усложняет работу команд.

## 5. Визуализация контекста системы — диаграмма С4

[Диаграмма контейнеров](apps/diagrams/as_is.puml)

# Задание 2. Проектирование микросервисной архитектуры


**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров](apps/diagrams/c4_containers.puml)

**Диаграмма компонентов (Components)**

[Диаграмма компонентов](apps/diagrams/c4-component_diagram.puml)

**Диаграмма кода (Code)**

[Диаграмма компонентов](apps/diagrams/c4-code_level.puml)

# Задание 3. Разработка ER-диаграммы

[ER -диаграмма](apps/diagrams/er-diagrams.puml)

# Задание 4. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры
