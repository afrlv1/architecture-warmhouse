# Project_template

# Задание 1. Анализ и планирование

<aside>

Проектная работа: экосистема «Тёплый дом»
Введение

Цель работы — спроектировать и частично реализовать целевую микросервисную экосистему умного дома для компании «Тёплый дом», исходя из исходного монолита (управление отоплением) и новых бизнес-требований (SaaS, самообслуживание, расширенный набор устройств, сценарии и телеметрия).

Работа включает:

- анализ текущего монолита и выделение доменов;

- проектирование микросервисной архитектуры (C4: Context, Containers, Components, Code);

- разработку ER-диаграммы;

- документирование API (REST + AsyncAPI);

- реализацию и упаковку сервиса temperature-api в Docker + настройку Postgres для smart_home.

</aside>

## 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователь через веб-интерфейс может удалённо включать/выключать отопление в доме.

**Мониторинг температуры:**

- Пользователь может просмотреть текущую температуру через веб-клиент.
- Система по запросу сервера получает текущую температуру от датчиков.

**Установка и подключение оборудования:**

- Пользователь не может самостоятельно зарегистрировать и подключить свой датчик/модуль.
- Подключение системы выполняется только специалистом компании.

## 2. Анализ архитектуры монолитного приложения

Текущее решение представляет собой монолитное приложение, обладающее следующими характеристиками:

### **Технологический стек**
- **Язык программирования:** Go  
- **СУБД:** PostgreSQL  
- **Архитектурный стиль:** монолит  
- **Развёртывание:** единый артефакт, обновляется целиком, требует полной остановки приложения

### **Функциональность монолита**
- Управление отоплением (включение/выключение)
- Получение температуры от датчиков по запросу
- Отображение текущих значений через веб-клиент
- Подключение устройств осуществляется только специалистом компании

### **Особенности взаимодействия**
- Все вызовы — **синхронные**
- Сервер самостоятельно инициирует опрос датчиков
- Взаимодействие идёт напрямую от сервера к устройствам

### **Ограничения архитектуры**
- **Ограниченная масштабируемость:** невозможно масштабировать отдельные части системы (например, только работу с отоплением)
- **Жёсткая связанность компонентов:** логика, API, работа с БД и интеграции находятся внутри одного приложения
- **Сложность внедрения новых модулей:** добавление освещения, ворот, камер, сценариев требует изменения монолита
- **Зависимость от штатных специалистов:** пользователь не может подключить своё устройство самостоятельно
- **Низкая гибкость:** нет реактивного взаимодействия, нет событийной модели, нет асинхронной обработки телеметрии

### **Итог**
Монолит подходит для простого управления отоплением, но не масштабируется под задачи экосистемы и SaaS-модели, что делает переход к микросервисной архитектуре необходимым.

## 3. Определение доменов и границы контекстов

На основании требований To-Be выделены домены и bounded contexts.

## Основные домены (To-Be)

### 1. Device Management (Управление устройствами)

- регистрация и активация устройств;
- привязка к домам и комнатам;
- хранение метаданных типов устройств (`DeviceType`, `Module`).

### 2. Heating (Отопление)

- управление режимами отопления;
- установка целевой температуры;
- получение состояния модуля отопления.

### 3. Lighting (Освещение)

- включение/выключение света;
- сценарии освещения.

### 4. Gates (Ворота)

- открытие/закрытие ворот;
- контроль состояния.

### 5. Surveillance (Наблюдение)

- управление доступом к видеопотоку;
- интеграция с внешними видеосистемами (логика доступа и управления, не хранение потоков внутри).

### 6. Telemetry (Телеметрия)

- приём телеметрии от устройств (температура, состояние, события);
- хранение и предоставление данных другим сервисам.

### 7. Scenario / Automation (Сценарии и автоматизация)

- хранение сценариев;
- условия и действия;
- инициирование команд в другие сервисы (`Heating`, `Lighting`, `Gates`).

### 8. User / Access (Пользователи и доступ)

- управление пользователями;
- аутентификация/авторизация.

## **4. Проблемы монолитного решения**

- Масштабирование только целиком. Нельзя независимо масштабировать управление отоплением, работу с устройствами, телеметрию и т.п.
- Синхронное взаимодействие с устройствами. Сервер должен опрашивать устройства, что при росте числа домов и датчиков приводит к росту задержек и нагрузки.
- Отсутствие самообслуживания. Пользователь не может сам зарегистрировать/подключить устройство, что тормозит развитие SaaS-модели
- Сложности с расширением. Добавление новых функций (освещение, ворота, камеры, сценарии) в один монолит ухудшает сопровождаемость и усложняет работу команд.

## 5. Визуализация контекста системы — диаграмма С4

[Диаграмма  As Is](apps/diagrams/as_is.puml)

# Задание 2. Проектирование микросервисной архитектуры

**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров](apps/diagrams/c4_containers.puml)

**Диаграмма компонентов (Components)**

[Диаграмма компонентов](apps/diagrams/c4-component_diagram.puml)

**Диаграмма кода (Code)**

[Диаграмма кода](apps/diagrams/c4-code_level.puml)

# Задание 3. Разработка ER-диаграммы

[ER -диаграмма](apps/diagrams/er-diagrams.puml)

# Задание 4. Создание и документирование API

После разработки ER-диаграммы и микросервисной архитектуры необходимо определить API, при помощи которого микросервисы будут взаимодействовать друг с другом. Ниже представлены выбор типов API, описание 4 REST-эндпоинтов и спецификация событийного канала для телеметрии.

---

## 1. Типы API

В системе используется два вида API — REST и событийный:

### 1.1. REST API (OpenAPI)

Используется для синхронного взаимодействия, когда требуется немедленный результат операции. Подходит для:

- CRUD-операций с сущностями (устройства, сценарии, пользователи);
- отправки команд доменным сервисам (например, Heating, Lighting);
- работы через API Gateway.

Документируется через **Swagger/OpenAPI**.

### 1.2. AsyncAPI (Событийный API)

Используется для асинхронного взаимодействия, при котором не требуется мгновенный ответ. Применяется для:

- получения телеметрии от устройств;
- оповещения сервисов (Scenario, Telemetry);
- событий типа «устройство отправило показания».

Документируется с помощью **AsyncAPI**.

---

## 2. REST API (4 ключевых эндпоинта)

Ниже представлены 4 основных REST-эндпоинта, обеспечивающих взаимодействие микросервисов.

---

### 2.1. POST /devices — регистрация устройства

**Назначение**  
Регистрация нового устройства и привязка его к дому.

**Метод**  
`POST /devices`

**Пример запроса (JSON)**

```json
{
  "device_type_id": "type-123",
  "house_id": "house-001",
  "serial_number": "SN-7784",
  "name": "Термостат гостиная"
}
```

**Пример ответа (JSON)**

```json
{
  "id": "dev-555",
  "device_type_id": "type-123",
  "house_id": "house-001",
  "serial_number": "SN-7784",
  "name": "Термостат гостиная",
  "status": "offline",
  "created_at": "2025-01-01T12:00:00Z"
}

```
**Коды ответа**

- `201 Created`
- `400 Bad Request`
- `409 Conflict`
- `500 Internal Server Error`

### 2.2. GET /devices/{id} — получение информации об устройстве

**Назначение**  
Получение информации об устройстве по его идентификатору.

**Метод**  
`GET /devices/{id}`

**Пример ответа (200 OK)**

```json
{
  "id": "dev-555",
  "device_type_id": "type-123",
  "house_id": "house-001",
  "serial_number": "SN-7784",
  "name": "Термостат гостиная",
  "status": "online",
  "last_seen_at": "2025-01-01T12:05:00Z",
  "firmware_version": "1.0.2"
}
```
**Коды ответа**

- `200 OK`
- `404 Not Found`
- `500 Internal Server Error`

### 2.3. POST /devices/{id}/command — отправка команды устройству

**Назначение**  
Передача команды управляющему устройству.

**Метод**  
`POST /devices/{id}/command`

**Пример запроса**

```json
{
  "command": "SET_TEMPERATURE",
  "payload": {
    "target_temp": 22.5
  }
}
```
**Пример ответа**

```json
{
  "device_id": "dev-555",
  "command": "SET_TEMPERATURE",
  "status": "accepted",
  "queued_at": "2025-01-01T12:06:00Z"
}
```
**Коды ответа**

- `201 Created`
- `400 Bad Request`
- `404 Not Found`
- `500 Internal Server Error`


### 2.4. POST /scenarios — создание сценария автоматизации

**Назначение**  
Создание сценария, который реагирует на телеметрию и выполняет действия над устройствами.

**Метод**  
`POST /scenarios`

**Пример запроса**

```json
{
  "house_id": "house-001",
  "name": "Night Heating",
  "conditions": [
    {
      "device_id": "dev-555",
      "metric_type": "temperature",
      "operator": "<",
      "value": "18"
    }
  ],
  "actions": [
    {
      "target_device_id": "dev-555",
      "command": "SET_TEMPERATURE",
      "command_payload": {
        "target_temp": 22
      }
    }
  ]
}
```
**Пример ответа**

```json
{
  "id": "scn-1001",
  "house_id": "house-001",
  "name": "Night Heating",
  "is_active": true,
  "created_at": "2025-01-01T12:10:00Z"
}

```
**Коды ответа**

- `201 Created`
- `400 Bad Request`
- `404 Not Found`
- `500 Internal Server Error`

## 3. Событийный API (AsyncAPI)

Телеметрия передаётся асинхронно через брокер сообщений (Kafka/RabbitMQ). Ниже описан основной канал.

---

### 3.1. Канал `telemetry.device.data`

**Назначение**  
Передача телеметрии от устройств (температура, состояние, события).

**Тип взаимодействия**  
Publisher → Subscribers

- **Publisher:** устройство или Device Management  
- **Subscribers:** Telemetry Service, Scenario Service  

---

**Формат сообщения**

```json
{
  "device_id": "dev-555",
  "timestamp": "2025-01-01T12:00:00Z",
  "metric_type": "temperature",
  "value_number": 21.7,
  "value_text": null,
  "raw_payload": {
    "temp_raw": 217
  }
}
```
[device-management.yaml](apps/docs/device-management.yaml)
[heating.yaml](apps/docs/heating.yaml)
[lighting.yaml](apps/docs/lighting.yaml)
[gates.yaml](apps/docs/gates.yaml)
[scenario.yaml](apps/docs/scenario.yaml)
[telemetry.yaml](apps/docs/telemetry.yaml)


# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры
